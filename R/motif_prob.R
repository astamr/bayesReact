#' Calculate the probability of motif occurrence in each sequence
#' @description This function calculates the probability of motif occurrence in each sequence and counts the number of non-overlapping motif occurrences.
#' The probability of motif occurrence is calculated using a Markov chain and becomes increasingly computationally exhaustive given the length and number of motifs.
#' Therefore, the function is parallelized to speed up computation, and at least 16 cores with 128 GB of RAM is recommended when running the function for all 7-mers.
#'
#' @param motifs A vector of motifs (e.g., c("ACGTAGT", "GTACAAG")) or an integer specifying the k-mers to be used (e.g., 7 for all 7-mers). A motif is specified as a regular expression with the alphabet {A,C,G,T}.
#' @param seqs A data frame with the columns: 'gid', 'sequence', and 'nchar' (generated by build_seq_list()).
#' @param seqlist A list of sequences (generated by build_seq_list()).
#' @param paths Boolean specifying whether the input data is provided as file paths or as R objects.
#' @param binom_approx Boolean specifying whether to use a binomial approximation to calculate motif probabilities or the default n-step TPM assuming an underlying markov chain. The binomial method assumes equal nucleotide frequencies
#' as well as a random and independent distribution of nucleotides in the sequence of interest. The approach is most appropriate when considering a large set of longer k-mers (> 7-mers). If binom_approx = T, 'motifs' has to be specified as a k-mer (e.g., motifs = 7 for all 7-mers).
#' @param cores Number of cores to use for parallelization. Consider increasing number of cores for large k-mers (default is the number of cores available).
#' @param out_path Path to output directory (default is NULL, where the output is returned rather than saved).
#' @param include_counts The default is TRUE and ensures that the matrix with motif counts is also returned. This parameter should ONLY be FALSE when running a light-weight approx. approach on a smaller computer.
#'
#' @return Two matrices, motif_probs and motif_counts, containing sequence-specific motif probabilities and motif counts, respectively.
#' @export
#'
#' @examples
#' \dontrun{
#' motif_prob_count_lst <- motif_prob(motifs = c("ACGTAGT", "GTACAAG"),
#' seqs = "./seqs.rds", seqlist = "./seqlist.rds",
#' binom_approx = F, cores = 4)
#'
#' motif_prob(motifs = 7, seqs = seqs, seqlist = seqlist, paths = F,
#' binom_approx = T, out_path = "./")
#' }
#'
#'
#' # ADD GREB TIL motif COUNTS!! (FAST WAY TO ENSURE ALSO GETTING COUNT DATA FOR APPROX APPROACH)
motif_prob <- function(motifs, seqs, seqlist, paths = T, binom_approx = F, cores = parallel::detectCores(),
                       out_path = NULL, include_counts = T) {
  # Initial checks

  # Load data if file paths provided
  if(paths) {
    seqs <- readRDS(seqs)
    seqlist <- readRDS(seqlist)
  }
  # Check if integer is specified to obtain all k-mers
  if (is.integer(motifs)){
    motifs <- Regmex::all.mers(motifs)
  }

  # Extract non-overlapping motif counts for each sequence
  if (include_counts) {
    motif_counts <- do.call(cbind, parallel::mclapply(motifs, function(x) Regmex:::n.obs.mot(x, seqlist, overlap =F), mc.cores = cores))
    colnames(motif_counts) <- motifs
    rownames(motif_counts) <- seqs$gid # match sequence and expression names/gene IDs
  }

  if (binom_approx == F) {
    # Generate state-space matrix (used to construct markov chain; consisting of initial state and transition probabilities)
    patterns <- parallel::mclapply(motifs, function(x) Regmex:::pat.con(x, overlap = F), mc.cores = cores)
    names(patterns) <- motifs

    # Compute probability of motif occurrence in each sequence
    motif_probs <- do.call(cbind, parallel::mclapply(patterns, function(x) unlist(lapply(seqlist, function(y) bayesReact:::pd.mrs2(x,y))), mc.cores = cores))
    colnames(motif_probs) <- motifs
    rownames(motif_probs) <- seqs$gid # match sequence and expression names/gene IDs

    # Check for NAs
    if(NA %in% motif_probs) stop("NA introduced when calculating motif probabilities. Try checking input data for errors.", call. = F)

  } else { # Binomial approximation

    # Check that method is only used for k-mers
    if(!is.numeric(motifs)) stop("'motifs' should be an integer specifying the k-mers to by used. Alternatively, consider using binom_approx = F.", call. = F)

    # Calculate probability of at least one motif occurrence in each sequence
    # !!!!!! CONSIDER MMN implementation, which works for all RE! !!!!!!!!
    binom_prob <- function(motif, seq_freq, seq_len){
      mot_len <- nchar(motif)
      motif <- unlist(strsplit(motif, ""))
      trials <- seq_len - mot_len + 1 # number of trials is the number of positions where a motif can potentially occur in the sequence
      mot_occ_prob <- unlist(lapply(motif, function(x) seq_freq[x])) # probability of each nucleotide in the motif is its frequency in the sequence
      mot_occ_prob <- prod(mot_occ_prob) # probability of motif occurrence (success at each trial) is the product of the probabilities of each nucleotide in the motif

      # Probability of no motif occurrence in the sequence is the probability of failure at each trial
      no_motif_prob <- (1 - mot_occ_prob)^trials
      # Probability of at least one motif occurrence in the sequence thus becomes '1 - probability of no motif occurrence'
      return(1 - no_motif_prob)
    }

    # Calculate motif probabilities for each motif in each sequence
    motif_probs <- do.call(rbind, parallel::mclapply(motifs, function(x) unlist(lapply(seqlist, function(y) binom_prob(x, y[2]$freq.mono, y[5]$length))), mc.cores = cores))
    rownames(motif_probs) <- motifs
    colnames(motif_probs) <- seqs$gid # match sequence and expression names/gene IDs
    motif_probs <- t(motif_probs) # transpose to match the format of the output from the non-approximate approach
  }

  # Save or return motif probabilities
  if (include_counts == F){
    if (is.character(out_path)) {
      saveRDS(motif_probs, file = paste0(out_path, "seqXmot_probs.rds"))
      #return(print(paste0("Matrix with motif probabilities saved to ", out_path, "seqXmot_probs.rds")))
      return(list(motif_probs_path = paste0(out_path, "seqXmot_probs.rds"))) # Used by process_raw_input()
    } else {
      return(motif_probs)
    }
  }

  if (is.character(out_path)) {
    saveRDS(motif_counts, file = paste0(out_path, "seqXmot_counts.rds"))
    saveRDS(motif_probs, file = paste0(out_path, "seqXmot_probs.rds"))
    #return(print(paste0("Matrix with motif probabilities saved to ", out_path, "seqXmot_probs.rds and counts saved to seqXmot_counts.rds")))
    return(list(motif_probs_path = paste0(out_path, "seqXmot_probs.rds"), motif_counts_path = paste0(out_path, "seqXmot_counts.rds"))) # Used by process_raw_input()
  } else {
    return(list(motif_probs = motif_probs, motif_counts = motif_counts))
  }
}
